Tests: it-works
util: rm

1) SECURITY: when recursing into a directory, pass the struct
stat obtained from lstat(2) into the rm_directory() function.
After open(2)ing the directory, issue an fstat(2) and verify that
the two stat structs refer to the same file.  Decide what to do if
they do not match (race).

<al viro>
  1) can_write(): it doesn't come anywhere near the write permissions
  logics.
	* other-writable does *not* mean owner-writable.  Neither does
  group-writable, for that matter.  Relevant part of st_mode is determined
  first and then everything else is ignored.
	* more importantly, for group permissions you need to look at
  getgroups() results in addition to getegid() one.

  2) rm_directory(): sorry, but failure of open() does mean that fchdir()
  will fail, so check for (!opt_force) makes no sense whatsoever (it only
  makes sure that -f will get message about EBADF instead of one about the
  real cause of problem).  If you want it to be silent, have perror()
  conditional on !opt_force and leave bailing outside of the inner if().

  3) FWIW, what about other perror() in there?  Which ones should be
  silenced?

  4) you ought to check if NULL from readdir() is due to EOF.  Error will
  have errno set (watch out for your rm() calls in the loop body leaving
  errno from their errors)

  5) fchdir() back *CAN* fail.  E.g. if you've lost exec permissions on
  directory you are going back to.  Your code assumes that rm() and
  rm_directory() will not leave you with changed cwd even in case of
  error.  Not true and potentially dangerous...

  6) !@!@! rm_directory() follows symlinks.  Yes, you've done lstat(2).
  Yes, it used to be S_ISDIR.  No, you can *not* assume that it will
  remain a directory by the time of open().  fstat() after open and
  check if it still matches.
</al viro>
